<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HDLC-Daemon: FrameEndpoint Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HDLC-Daemon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classFrameEndpoint.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classFrameEndpoint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FrameEndpoint Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="classFrameEndpoint.html" title="Class FrameEndpoint. ">FrameEndpoint</a>.  
 <a href="classFrameEndpoint.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FrameEndpoint:</div>
<div class="dyncontent">
<div class="center"><img src="classFrameEndpoint__inherit__graph.png" border="0" usemap="#FrameEndpoint_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for FrameEndpoint:</div>
<div class="dyncontent">
<div class="center"><img src="classFrameEndpoint__coll__graph.png" border="0" usemap="#FrameEndpoint_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a178e55ba831e53fb8eb7d8fcb816e53e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#a178e55ba831e53fb8eb7d8fcb816e53e">FrameEndpoint</a> (boost::asio::io_service &amp;a_IOService, boost::asio::ip::tcp::socket &amp;a_TcpSocket, uint8_t a_FrameTypeMask=0xFF)</td></tr>
<tr class="memdesc:a178e55ba831e53fb8eb7d8fcb816e53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor of <a class="el" href="classFrameEndpoint.html" title="Class FrameEndpoint. ">FrameEndpoint</a> objects.  <a href="#a178e55ba831e53fb8eb7d8fcb816e53e">More...</a><br /></td></tr>
<tr class="separator:a178e55ba831e53fb8eb7d8fcb816e53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53760ef897d37e1e6aeade53b1c9766"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#ab53760ef897d37e1e6aeade53b1c9766">~FrameEndpoint</a> ()</td></tr>
<tr class="memdesc:ab53760ef897d37e1e6aeade53b1c9766"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor of <a class="el" href="classFrameEndpoint.html" title="Class FrameEndpoint. ">FrameEndpoint</a> objects.  <a href="#ab53760ef897d37e1e6aeade53b1c9766">More...</a><br /></td></tr>
<tr class="separator:ab53760ef897d37e1e6aeade53b1c9766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf33b5f5e61e19196c320ceadf7ecdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#a0cf33b5f5e61e19196c320ceadf7ecdd">ResetFrameFactories</a> (uint8_t a_FrameTypeMask=0xFF)</td></tr>
<tr class="memdesc:a0cf33b5f5e61e19196c320ceadf7ecdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forget all provided frame factory callbacks.  <a href="#a0cf33b5f5e61e19196c320ceadf7ecdd">More...</a><br /></td></tr>
<tr class="separator:a0cf33b5f5e61e19196c320ceadf7ecdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea55d7b0c6f7236c27022992f205aeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#a1ea55d7b0c6f7236c27022992f205aeb">RegisterFrameFactory</a> (unsigned char a_FrameType, std::function&lt; std::shared_ptr&lt; <a class="el" href="classFrame.html">Frame</a> &gt;(void)&gt; a_FrameFactory)</td></tr>
<tr class="memdesc:a1ea55d7b0c6f7236c27022992f205aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register one subsequent frame factory callback.  <a href="#a1ea55d7b0c6f7236c27022992f205aeb">More...</a><br /></td></tr>
<tr class="separator:a1ea55d7b0c6f7236c27022992f205aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2f8f8f92f8f2dd56b43788ff32326b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#a9e2f8f8f92f8f2dd56b43788ff32326b">GetWasStarted</a> () const </td></tr>
<tr class="memdesc:a9e2f8f8f92f8f2dd56b43788ff32326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A getter to query whether this frame endpoint entity was already started.  <a href="#a9e2f8f8f92f8f2dd56b43788ff32326b">More...</a><br /></td></tr>
<tr class="separator:a9e2f8f8f92f8f2dd56b43788ff32326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae286265b547f84f19b9a3a3e375a5fe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#ae286265b547f84f19b9a3a3e375a5fe1">Start</a> ()</td></tr>
<tr class="memdesc:ae286265b547f84f19b9a3a3e375a5fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the frame endpoint entity.  <a href="#ae286265b547f84f19b9a3a3e375a5fe1">More...</a><br /></td></tr>
<tr class="separator:ae286265b547f84f19b9a3a3e375a5fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0452cb8274bed71dccd4c1b3a66ed619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#a0452cb8274bed71dccd4c1b3a66ed619">Shutdown</a> ()</td></tr>
<tr class="memdesc:a0452cb8274bed71dccd4c1b3a66ed619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tear a frame endpoint entity down.  <a href="#a0452cb8274bed71dccd4c1b3a66ed619">More...</a><br /></td></tr>
<tr class="separator:a0452cb8274bed71dccd4c1b3a66ed619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7eea9fd66860006653b3173c06eab23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#ad7eea9fd66860006653b3173c06eab23">Close</a> ()</td></tr>
<tr class="memdesc:ad7eea9fd66860006653b3173c06eab23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the frame endpoint entity.  <a href="#ad7eea9fd66860006653b3173c06eab23">More...</a><br /></td></tr>
<tr class="separator:ad7eea9fd66860006653b3173c06eab23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b3e65d99955094ca324f66e43859f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#a95b3e65d99955094ca324f66e43859f2">TriggerNextFrame</a> ()</td></tr>
<tr class="memdesc:a95b3e65d99955094ca324f66e43859f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger delivery of the next incoming frame.  <a href="#a95b3e65d99955094ca324f66e43859f2">More...</a><br /></td></tr>
<tr class="separator:a95b3e65d99955094ca324f66e43859f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa672b6a8a3444735ee233f9dc7c55d41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#aa672b6a8a3444735ee233f9dc7c55d41">SendFrame</a> (const <a class="el" href="classFrame.html">Frame</a> &amp;a_Frame, std::function&lt; void()&gt; a_OnSendDoneCallback=nullptr)</td></tr>
<tr class="memdesc:aa672b6a8a3444735ee233f9dc7c55d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a frame for transmission.  <a href="#aa672b6a8a3444735ee233f9dc7c55d41">More...</a><br /></td></tr>
<tr class="separator:aa672b6a8a3444735ee233f9dc7c55d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff047fa5847a8bbc582b696f7757fd14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#aff047fa5847a8bbc582b696f7757fd14">SetOnFrameCallback</a> (std::function&lt; bool(std::shared_ptr&lt; <a class="el" href="classFrame.html">Frame</a> &gt;)&gt; a_OnFrameCallback)</td></tr>
<tr class="memdesc:aff047fa5847a8bbc582b696f7757fd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the callback method for handling of incoming frames.  <a href="#aff047fa5847a8bbc582b696f7757fd14">More...</a><br /></td></tr>
<tr class="separator:aff047fa5847a8bbc582b696f7757fd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a5df936321813329b570c22b268c67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameEndpoint.html#aa1a5df936321813329b570c22b268c67">SetOnClosedCallback</a> (std::function&lt; void()&gt; a_OnClosedCallback)</td></tr>
<tr class="memdesc:aa1a5df936321813329b570c22b268c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the callback method for handling of connection aborts.  <a href="#aa1a5df936321813329b570c22b268c67">More...</a><br /></td></tr>
<tr class="separator:aa1a5df936321813329b570c22b268c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class <a class="el" href="classFrameEndpoint.html" title="Class FrameEndpoint. ">FrameEndpoint</a>. </p>
<p>This is a convenience class to take full control over a provided connected TCP socket in order to receive and transmit used-defined frames. The user has to provide callbacks to be notified on reception of incoming frames and to be notified if errors occur. Thus, this class offers a fully asynchronous interface.</p>
<p><a class="el" href="classFrame.html" title="Class Frame. ">Frame</a> objects representing received frames are created internally. For this purpose, the user has to register frame factory callbacks. These frame factories are selected according to the received stream of bytes and offer a very easy interface to the user. Currently, this frame selection scheme requires that the type of frame can be determined by evaluation of the very first byte of a frame. If this is not possible, e.g., because multiple types of frames exist which differ in "later" bytes, this <a class="el" href="classFrameEndpoint.html" title="Class FrameEndpoint. ">FrameEndpoint</a> class is not suitable! </p>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00065">65</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a178e55ba831e53fb8eb7d8fcb816e53e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FrameEndpoint::FrameEndpoint </td>
          <td>(</td>
          <td class="paramtype">boost::asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>a_IOService</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::ip::tcp::socket &amp;&#160;</td>
          <td class="paramname"><em>a_TcpSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>a_FrameTypeMask</em> = <code>0xFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor of <a class="el" href="classFrameEndpoint.html" title="Class FrameEndpoint. ">FrameEndpoint</a> objects. </p>
<p>All internal members are initialized here. The ownership of the provided TCP socket is transferred, so the user MUST NOT perform any operations on it after registration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_IOService</td><td>the boost IO service object </td></tr>
    <tr><td class="paramname">a_TcpSocket</td><td>the connected TCP socket </td></tr>
    <tr><td class="paramname">a_FrameTypeMask</td><td>the mask used while looking at the "first byte" of each frame to determine its type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00076">76</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab53760ef897d37e1e6aeade53b1c9766"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FrameEndpoint::~FrameEndpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor of <a class="el" href="classFrameEndpoint.html" title="Class FrameEndpoint. ">FrameEndpoint</a> objects. </p>
<p>On destruction, it is assured that the provided TCP socket is closed correctly. No subsequent callbacks are triggered. </p>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00093">93</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classFrameEndpoint_ab53760ef897d37e1e6aeade53b1c9766_cgraph.png" border="0" usemap="#classFrameEndpoint_ab53760ef897d37e1e6aeade53b1c9766_cgraph" alt=""/></div>
<map name="classFrameEndpoint_ab53760ef897d37e1e6aeade53b1c9766_cgraph" id="classFrameEndpoint_ab53760ef897d37e1e6aeade53b1c9766_cgraph">
<area shape="rect" id="node2" href="classFrameEndpoint.html#ad7eea9fd66860006653b3173c06eab23" title="Close the frame endpoint entity. " alt="" coords="281,5,441,32"/>
</map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad7eea9fd66860006653b3173c06eab23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FrameEndpoint::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the frame endpoint entity. </p>
<p>Invoking this method will instantly stop reception of incoming and transmission of outgoing frames. Frames pending in the send queue will be lost. No problems arise if this method is called multiple times. Consider calling <a class="el" href="classFrameEndpoint.html#a0452cb8274bed71dccd4c1b3a66ed619" title="Tear a frame endpoint entity down. ">Shutdown()</a> instead. </p>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00181">181</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classFrameEndpoint_ad7eea9fd66860006653b3173c06eab23_icgraph.png" border="0" usemap="#classFrameEndpoint_ad7eea9fd66860006653b3173c06eab23_icgraph" alt=""/></div>
<map name="classFrameEndpoint_ad7eea9fd66860006653b3173c06eab23_icgraph" id="classFrameEndpoint_ad7eea9fd66860006653b3173c06eab23_icgraph">
<area shape="rect" id="node2" href="classFrameEndpoint.html#ab53760ef897d37e1e6aeade53b1c9766" title="The destructor of FrameEndpoint objects. " alt="" coords="213,5,441,32"/>
<area shape="rect" id="node3" href="classFrameEndpoint.html#aa1a5df936321813329b570c22b268c67" title="Provide the callback method for handling of connection aborts. " alt="" coords="223,57,431,98"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9e2f8f8f92f8f2dd56b43788ff32326b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FrameEndpoint::GetWasStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A getter to query whether this frame endpoint entity was already started. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true,if</td><td>the frame endpoint is currently running </td></tr>
    <tr><td class="paramname">false,if</td><td>the frame endpoint is currently not running </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool, indicating whether this frame endpoint entity was already started </dd></dl>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00137">137</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1ea55d7b0c6f7236c27022992f205aeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FrameEndpoint::RegisterFrameFactory </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>a_FrameType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::shared_ptr&lt; <a class="el" href="classFrame.html">Frame</a> &gt;(void)&gt;&#160;</td>
          <td class="paramname"><em>a_FrameFactory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register one subsequent frame factory callback. </p>
<p>This method is use to clear the list of provided frame factory callbacks. After this, a new and completely different set of frame factory callbacks can be provided together with a changed frame type mask. This allows changing the user-defined protocol regarding a TCP socket for which a different protocol was specified earlier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_FrameType</td><td>the frame type together with the frame type mask must match to activate the respective frame factory callback </td></tr>
    <tr><td class="paramname">a_FrameFactory</td><td>the frame factory callback that is invoked if the frame type matches </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00123">123</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0cf33b5f5e61e19196c320ceadf7ecdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FrameEndpoint::ResetFrameFactories </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>a_FrameTypeMask</em> = <code>0xFF</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forget all provided frame factory callbacks. </p>
<p>This method is use to clear the list of provided frame factory callbacks. After this, a new and completely different set of frame factory callbacks can be provided together with a changed frame type mask. This allows changing the user-defined protocol regarding a TCP socket for which a different protocol was specified earlier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_FrameTypeMask</td><td>the mask used while looking at the "first byte" of each frame to determine its type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00108">108</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa672b6a8a3444735ee233f9dc7c55d41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FrameEndpoint::SendFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFrame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>a_Frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>a_OnSendDoneCallback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a frame for transmission. </p>
<p>Use this method to enqueue a frame for transmission. The user can select between quasi-synchonous and asynchronous behavior. In the first case, one has to evaluate the return value to check whether a provided frame was accepted or denied due to a full transmission queue. For asynchronous behavior the user has to provide a callback method on a per-packet basis that is called after the frame was successfully transmitted. Currently this callback method is only called on success but never on error, e.g., if the socket is closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_Frame</td><td>the frame to send </td></tr>
    <tr><td class="paramname">a_OnSendDoneCallback</td><td>a callback to be invoked if this frame was sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true,if</td><td>the frame was successfully enqueued </td></tr>
    <tr><td class="paramname">false,if</td><td>ehere was a problem enqueueing the frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool, to indicate whether the frame was successfully enqueued for transmission </dd></dl>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00238">238</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classFrameEndpoint_aa672b6a8a3444735ee233f9dc7c55d41_cgraph.png" border="0" usemap="#classFrameEndpoint_aa672b6a8a3444735ee233f9dc7c55d41_cgraph" alt=""/></div>
<map name="classFrameEndpoint_aa672b6a8a3444735ee233f9dc7c55d41_cgraph" id="classFrameEndpoint_aa672b6a8a3444735ee233f9dc7c55d41_cgraph">
<area shape="rect" id="node2" href="classFrame.html#ad25373889d9cceacc902b98339456ee4" title="The purely virtual serializer method. " alt="" coords="251,5,373,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa1a5df936321813329b570c22b268c67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FrameEndpoint::SetOnClosedCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>a_OnClosedCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the callback method for handling of connection aborts. </p>
<p>The user should provide one callback method to be able to handle error events such as a closed TCP socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_OnClosedCallback</td><td>the callback method that is invoked on error or if the socket was closed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00282">282</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classFrameEndpoint_aa1a5df936321813329b570c22b268c67_cgraph.png" border="0" usemap="#classFrameEndpoint_aa1a5df936321813329b570c22b268c67_cgraph" alt=""/></div>
<map name="classFrameEndpoint_aa1a5df936321813329b570c22b268c67_cgraph" id="classFrameEndpoint_aa1a5df936321813329b570c22b268c67_cgraph">
<area shape="rect" id="node2" href="classFrameEndpoint.html#ad7eea9fd66860006653b3173c06eab23" title="Close the frame endpoint entity. " alt="" coords="281,5,441,32"/>
<area shape="rect" id="node3" href="classFrameEndpoint.html#a95b3e65d99955094ca324f66e43859f2" title="Trigger delivery of the next incoming frame. " alt="" coords="261,57,460,98"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aff047fa5847a8bbc582b696f7757fd14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FrameEndpoint::SetOnFrameCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(std::shared_ptr&lt; <a class="el" href="classFrame.html">Frame</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>a_OnFrameCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the callback method for handling of incoming frames. </p>
<p>The user should provide one callback method to be able to handle incoming frames. For each incoming frame the callback method is called once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_OnFrameCallback</td><td>the callback method that is invoked on reception of incoming frames </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00272">272</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0452cb8274bed71dccd4c1b3a66ed619"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FrameEndpoint::Shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tear a frame endpoint entity down. </p>
<p>This method should be called instead of <a class="el" href="classFrameEndpoint.html#ad7eea9fd66860006653b3173c06eab23" title="Close the frame endpoint entity. ">Close()</a> if you want to assure a proper teardown sequence of the provided TCP socket. This assures that all frames enqueued for transmission are delivered before the socket is closed. You SHOULD NOT call <a class="el" href="classFrameEndpoint.html#ad7eea9fd66860006653b3173c06eab23" title="Close the frame endpoint entity. ">Close()</a> anymore, as this is performed internally as soon as the send queue becomes empty. You SHOULD NOT send subsequent frames after calling this method as you'll get no feedback whether the respective frame will be transmitted or not. </p>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00172">172</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae286265b547f84f19b9a3a3e375a5fe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FrameEndpoint::Start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the frame endpoint entity. </p>
<p>The frame endpoint starts reading data from the socket and creates a stream of frame objects according to the provided frame factory callback methods. Frames enqued for transmission are delivered in sequence. Be sure that you DO NOT call this method twice, i.e., on a frame endpoint entity that is already running. This will trigger an assertion. </p>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00147">147</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classFrameEndpoint_ae286265b547f84f19b9a3a3e375a5fe1_cgraph.png" border="0" usemap="#classFrameEndpoint_ae286265b547f84f19b9a3a3e375a5fe1_cgraph" alt=""/></div>
<map name="classFrameEndpoint_ae286265b547f84f19b9a3a3e375a5fe1_cgraph" id="classFrameEndpoint_ae286265b547f84f19b9a3a3e375a5fe1_cgraph">
<area shape="rect" id="node2" href="classFrameEndpoint.html#a95b3e65d99955094ca324f66e43859f2" title="Trigger delivery of the next incoming frame. " alt="" coords="208,5,407,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a95b3e65d99955094ca324f66e43859f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FrameEndpoint::TriggerNextFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigger delivery of the next incoming frame. </p>
<p>Invoking this method triggers read and delivery of the next incoming frame. This allows an asynchronous processing of frames. For such an asynchronous mode of operation, the provided OnFrameCallback must return the value "false" in order to stop automatic delivery of subsequent frames. This provides unlimited time to consume a frame and stalls the TCP socket, but requires a later call to this method in order to continue receiving the next incoming frame. </p>

<p>Definition at line <a class="el" href="FrameEndpoint_8h_source.html#l00200">200</a> of file <a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classFrameEndpoint_a95b3e65d99955094ca324f66e43859f2_icgraph.png" border="0" usemap="#classFrameEndpoint_a95b3e65d99955094ca324f66e43859f2_icgraph" alt=""/></div>
<map name="classFrameEndpoint_a95b3e65d99955094ca324f66e43859f2_icgraph" id="classFrameEndpoint_a95b3e65d99955094ca324f66e43859f2_icgraph">
<area shape="rect" id="node2" href="classFrameEndpoint.html#ae286265b547f84f19b9a3a3e375a5fe1" title="Start the frame endpoint entity. " alt="" coords="279,5,433,32"/>
<area shape="rect" id="node3" href="classFrameEndpoint.html#aa1a5df936321813329b570c22b268c67" title="Provide the callback method for handling of connection aborts. " alt="" coords="252,57,460,98"/>
</map>
</div>
</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libs/framing/src/<a class="el" href="FrameEndpoint_8h_source.html">FrameEndpoint.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classFrameEndpoint.html">FrameEndpoint</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
